// Prisma schema for HealthX AI Wellness Platform (refactored for Submission model)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum QuestionCategory {
  foodReactions
  metabolicDysfunction
  oralHealth
  gutDysbiosis
  environmentalToxins
  foreignObjects
  stealthInfections
  nervousSystem
}

enum UserRole {
  PATIENT
  DOCTOR
  ADMIN
}

enum MembershipTier {
  BASIC
  PREMIUM
  VIP
}

model User {
  id        String   @id @default(uuid())
  name      String?
  email     String   @unique
  role      UserRole @default(PATIENT)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  submissions Submission[]
  treatments  Treatment[]
  threads     Thread[]
  memberships Membership[]
  checkIns    CheckIn[]
  habitLogs   HabitLog[]
  // Referrals
  referralCode    String?   @unique
  referredByUserId String?
  referredBy       User?     @relation("UserReferredBy", fields: [referredByUserId], references: [id])
  referredUsers    User[]    @relation("UserReferredBy")
  referralsMade    Referral[] @relation("UserReferralsMade")
  referralsReceived Referral[] @relation("UserReferralsReceived")
}

model Question {
  id             String           @id @default(uuid())
  text           String
  category       QuestionCategory
  orderInSection Int
  possibleValues Json // e.g., [0,2,4,6,8]
  answers        SubmissionAnswer[]
}

model Submission {
  id           String           @id @default(uuid())
  userId       String
  createdAt    DateTime         @default(now())
  user         User             @relation(fields: [userId], references: [id])
  answers      SubmissionAnswer[]
  threads      Thread[]         // 1:N relationship (submission can have multiple threads via reruns)
  treatments   Treatment[]      // 1:N relationship (submission can have multiple treatments via reruns)
}

model SubmissionAnswer {
  id            String      @id @default(uuid())
  submissionId  String
  questionId    String
  answer        String
  createdAt     DateTime    @default(now())
  submission    Submission  @relation(fields: [submissionId], references: [id])
  question      Question    @relation(fields: [questionId], references: [id])
}

model Treatment {
  id           String          @id @default(uuid())
  userId       String
  threadId     String?         @unique // 1:1 relationship with thread
  submissionId String?         // Link to the submission that created this treatment
  source       String          // "ai", "doctor", etc.
  planJson     Json
  status       TreatmentStatus @default(PENDING)
  createdAt    DateTime        @default(now())
  reviewedBy   String?
  user         User            @relation(fields: [userId], references: [id])
  thread       Thread?         @relation(fields: [threadId], references: [id])
  submission   Submission?     @relation(fields: [submissionId], references: [id])
  doctor       Doctor?         @relation("DoctorReviewedPlans", fields: [reviewedBy], references: [id])
  items        TreatmentItem[]
}

model TreatmentItem {
  id              String              @id @default(uuid())
  treatmentId     String
  type            String              // e.g., 'root_protocol', 'vitamin', etc.
  name            String
  details         Json                // Additional details (dosage, frequency, etc.)
  status          TreatmentItemStatus @default(PENDING)
  reviewedBy      String?
  rejectionReason String?             // Optional reason for rejection
  treatment       Treatment           @relation(fields: [treatmentId], references: [id])
  doctor          Doctor?             @relation(fields: [reviewedBy], references: [id])
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
}

model Doctor {
  id             String          @id @default(uuid())
  name           String
  email          String          @unique
  password       String          // hashed
  createdAt      DateTime        @default(now())
  reviewedPlans  Treatment[]     @relation("DoctorReviewedPlans")
  reviewedItems  TreatmentItem[]
}

model Assistant {
  id         String   @id @default(uuid())
  openaiId   String   @unique
  name       String
  prompt     String
  filePaths  Json
  createdAt  DateTime @default(now())
  threads    Thread[]
}

model Thread {
  id             String     @id @default(uuid())
  openaiId       String     @unique
  assistantId    String
  userId         String
  submissionId   String?    // Link to the submission that created this thread
  initialMessage String?
  createdAt      DateTime   @default(now())
  assistant      Assistant  @relation(fields: [assistantId], references: [id])
  user           User       @relation(fields: [userId], references: [id])
  submission     Submission? @relation(fields: [submissionId], references: [id])
  treatment      Treatment? // 1:1 relationship with treatment
}

model ThreadPrompt {
  id          String               @id @default(uuid())
  name        String
  prompt      String               @db.Text
  type        ThreadPromptType     @default(TREATMENT)
  isActive    Boolean              @default(false)
  config      Json?
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
}

enum ThreadPromptType {
  TREATMENT
  TRAINING
}

enum TreatmentStatus {
  PENDING
  APPROVED
  REJECTED
  PARTIALLY_APPROVED
}

enum TreatmentItemStatus {
  PENDING
  APPROVED
  REJECTED
}

model Membership {
  id        String           @id @default(uuid())
  userId    String
  tier      MembershipTier
  startDate DateTime        @default(now())
  endDate   DateTime?
  status    String          // active, cancelled, expired
  user      User            @relation(fields: [userId], references: [id])
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
} 

/// Stores metadata for knowledge base files stored in Supabase and synced to OpenAI
model KnowledgeFile {
  id            String   @id @default(uuid())
  name          String   @unique                 // File name in the `kb` bucket (e.g., "Guide.pdf")
  title         String                           // Human-friendly title
  description   String   @db.Text                // Context/instructions for how to use this file
  bucketPath    String                           // e.g., "kb/Guide.pdf" (or just name if root)
  mimeType      String?
  sizeBytes     Int?
  isActive      Boolean  @default(true)          // Whether included in training
  openaiFileId  String?                          // File id on OpenAI after sync
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

/// Referral events linking referrer and referred users
model Referral {
  id               String   @id @default(uuid())
  referrerUserId   String
  referredUserId   String
  createdAt        DateTime @default(now())

  referrer         User     @relation("UserReferralsMade", fields: [referrerUserId], references: [id])
  referred         User     @relation("UserReferralsReceived", fields: [referredUserId], references: [id])

  @@unique([referrerUserId, referredUserId])
}

/// Daily patient check-ins for adherence and symptoms
model CheckIn {
  id            String   @id @default(uuid())
  userId        String
  date          DateTime @db.Date
  adherencePct  Int      // 0-100
  symptomScore  Int?     // 0-10
  blockerText   String?  @db.Text
  createdAt     DateTime @default(now())
  user          User     @relation(fields: [userId], references: [id])

  @@unique([userId, date])
}

/// Completion state for checklist items derived from the treatment plan
model HabitLog {
  id        String   @id @default(uuid())
  userId    String
  date      DateTime @db.Date
  itemId    String   // synthetic id like ts_r_s_i or a stable plan id
  completed Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId, date, itemId])
}